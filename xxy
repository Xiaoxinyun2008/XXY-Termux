# ==============================================================================
# 🌌 XXY v3000.0 Event Horizon (视界·无限版)
# TYPE: Enterprise-Grade Container Management System
# KERNEL: Absolute-UI v4.0 | Logic-Core v9.0 | Deep-Audit | Self-Healing
# ==============================================================================

# --- [SECTION 0] BOOTLOADER (引导层) ---
tput cnorm
clear

# 0.1 定义基础常量
export APP_NAME="XXY SYSTEM"
export APP_VER="v3000.0 PRO"
export PREFIX="/data/data/com.termux/files/usr"
export TMP_DIR="$PREFIX/tmp/xxy_event_horizon"
export SYS_CONF="$PREFIX/etc/proot-distro"
export ROOTFS="$PREFIX/var/lib/proot-distro/installed-rootfs"
export BACKUP_PATH="/sdcard/XXY_Backups"
export LOG_PATH="$TMP_DIR/runtime.log"
export LANG="C.UTF-8"

# 0.2 颜色矩阵 (Neon Palette)
C_RESET=$(tput sgr0)
C_BOLD=$(tput bold)
C_RED=$(tput setaf 196)
C_GREEN=$(tput setaf 46)
C_YELLOW=$(tput setaf 226)
C_BLUE=$(tput setaf 39)
C_PURPLE=$(tput setaf 201)
C_CYAN=$(tput setaf 51)
C_WHITE=$(tput setaf 255)
C_GREY=$(tput setaf 240)
C_DARK=$(tput setaf 236)

# 0.3 异常处理句柄
trap_crash() {
    tput cnorm
    stty echo
    echo -e "\n\n${C_RED}🛑 [FATAL ERROR] 系统内核崩溃或被强制中断。${C_RESET}"
    echo -e "${C_GREY}>> 正在生成错误转储 (Core Dump)...${C_RESET}"
    echo -e "${C_GREY}>> 资源已释放。安全退出。${C_RESET}"
    exit 1
}
trap trap_crash EXIT INT TERM

# 0.4 环境重置 (Deep Clean)
rm -f "$PREFIX/bin/xxy"
rm -rf "$TMP_DIR"
mkdir -p "$TMP_DIR"
mkdir -p "$BACKUP_PATH"

# 强杀干扰进程
kill_zombies() {
    local zombies="sshd termux-x11 pulseaudio Xwayland vncserver proot"
    for z in $zombies; do
        if pgrep -x "$z" >/dev/null; then killall -9 "$z" >/dev/null 2>&1; fi
    done
}
kill_zombies

# --- [SECTION 1] UI KERNEL (UI内核层) ---
cat > $PREFIX/bin/xxy << 'MAIN_EOF'
#!/data/data/com.termux/files/usr/bin/bash

# 引入外部变量
export TMP_DIR="/data/data/com.termux/files/usr/tmp/xxy_event_horizon"
export LOG_PATH="$TMP_DIR/runtime.log"
export C_RESET=$(tput sgr0); export C_BOLD=$(tput bold)
export C_RED=$(tput setaf 196); export C_GREEN=$(tput setaf 46)
export C_YELLOW=$(tput setaf 226); export C_BLUE=$(tput setaf 39)
export C_PURPLE=$(tput setaf 201); export C_CYAN=$(tput setaf 51)
export C_WHITE=$(tput setaf 255); export C_GREY=$(tput setaf 240)

# ==============================================================================
# 🖥️ DISPLAY DRIVER (显示驱动 - 解决刷新错误的核心)
# ==============================================================================

# [Dr-1] 绝对坐标绘制 (Absolute Draw)
# 参数: 行, 列, 内容
draw_at() {
    tput cup $1 $2
    echo -ne "$3"
}

# [Dr-2] 绘制矩形框 (Box Draw)
# 参数: y, x, height, width, color
draw_box() {
    local y=$1; local x=$2; local h=$3; local w=$4; local col=$5
    local H_LINE="━"; local V_LINE="┃"
    local TL="┏"; local TR="┓"; local BL="┗"; local BR="┛"
    
    # Top
    draw_at $y $x "${col}${TL}"
    for ((i=0; i<w-2; i++)); do echo -ne "${H_LINE}"; done
    echo -ne "${TR}${C_RESET}"
    
    # Sides
    for ((i=1; i<h-1; i++)); do
        draw_at $((y+i)) $x "${col}${V_LINE}${C_RESET}"
        draw_at $((y+i)) $((x+w-1)) "${col}${V_LINE}${C_RESET}"
    done
    
    # Bottom
    draw_at $((y+h-1)) $x "${col}${BL}"
    for ((i=0; i<w-2; i++)); do echo -ne "${H_LINE}"; done
    echo -ne "${BR}${C_RESET}"
}

# [Dr-3] 绘制居中文本
# 参数: y, width, text, color
draw_center() {
    local y=$1; local w=$2; local txt=$3; local col=$4
    local len=${#txt}
    local pad=$(( (w - len) / 2 ))
    tput cup $y $pad
    echo -ne "${col}${txt}${C_RESET}"
}

# [Dr-4] BIOS 自检动画 (增加仪式感)
boot_animation() {
    clear
    local steps=(
        "Loading Kernel Modules..."
        "Mounting Virtual Filesystem..."
        "Checking CPU Architecture..."
        "Initializing Graphics Engine..."
        "Connecting to Satellite..."
    )
    
    echo -e "${C_BLUE}XXY BIOS v3000.0 (c) 2024${C_RESET}"
    echo -e "Memory Test: ${C_GREEN}PASSED${C_RESET}"
    echo "--------------------------------"
    
    for step in "${steps[@]}"; do
        echo -ne "${C_GREY}[INIT] $step${C_RESET}"
        sleep 0.1
        echo -e "\r${C_GREEN}[OK]${C_RESET} $step   "
    done
    sleep 0.3
}

# ==============================================================================
# 🧠 LOGIC ENGINE (逻辑引擎)
# ==============================================================================

# [L-1] 输入哨兵 (Sentinel)
# 阻塞式读取，直到获得合法输入。绝不崩溃。
wait_input() {
    local valid_chars="$1"
    while true; do
        # 移动光标到命令输入区
        draw_at 20 14 "     " # 清除旧输入
        draw_at 20 14 ""
        read -n 1 input
        
        # 空输入处理
        if [ -z "$input" ]; then continue; fi
        
        # 校验
        if [[ "$valid_chars" == *"$input"* ]]; then
            RET="$input"
            return 0
        else
            # 错误提示闪烁
            draw_at 20 20 "${C_RED}❌ 无效指令${C_RESET}"
            sleep 0.5
            draw_at 20 20 "            "
        fi
    done
}

# [L-2] 硬件监控守护进程 (Watchdog)
get_status() {
    # Time
    TIME=$(date '+%H:%M:%S')
    
    # IP (Fast check)
    IP=$(ifconfig 2>/dev/null | grep -oE 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -n 1 | awk '{print $2}' | sed 's/addr://')
    [ -z "$IP" ] && IP="Offline"
    
    # RAM
    RAM_USED=$(free -m | awk 'NR==2{print $3}')
    RAM_TOT=$(free -m | awk 'NR==2{print $2}')
    
    # SSH Status
    if pgrep sshd >/dev/null; then
        CONN=$(netstat -tn 2>/dev/null | grep ':8022' | grep 'ESTABLISHED' | wc -l)
        if [ "$CONN" -gt 0 ]; then
            SSH_STAT="${C_RED}⚠️  入侵: $CONN${C_RESET}"
        else
            SSH_STAT="${C_GREEN}🟢 待机${C_RESET}"
        fi
    else
        SSH_STAT="${C_GREY}⚪ 关闭${C_RESET}"
    fi
    
    # Storage
    DISK=$(df -h /data | awk 'NR==2{print $4}')
}

# ==============================================================================
# 👷 WORKER SCRIPTS (工单系统)
# ==============================================================================
create_worker() {
    local f="$TMP_DIR/worker.sh"
    rm -f "$f"
    cat >> "$f" << 'EOF'
#!/bin/sh
set -e
export DEBIAN_FRONTEND=noninteractive
act=$1

# Auto-Detect Distro
if [ -f /etc/alpine-release ]; then T="alpine"; PM="apk"
elif [ -f /etc/arch-release ]; then T="arch"; PM="pacman"
elif [ -f /etc/debian_version ]; then T="debian"; PM="apt"
else T="unknown"; fi

case "$act" in
  src) 
    if [ "$T" = "debian" ]; then 
      if ! grep -q "tsinghua" /etc/apt/sources.list; then
        sed -i 's/http:\/\/ports.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g' /etc/apt/sources.list
        apt update -y
      fi
    elif [ "$T" = "alpine" ]; then
      sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories
      apk update
    fi ;;
    
  gui)
    if [ "$T" = "debian" ]; then apt install -y xfce4 xfce4-goodies dbus-x11 tigervnc-standalone-server
    elif [ "$T" = "alpine" ]; then apk add xfce4 dbus-x11 tigervnc; fi
    mkdir -p ~/.vnc
    echo "123456" | vncpasswd -f > ~/.vnc/passwd
    chmod 600 ~/.vnc/passwd ;;
    
  clean)
    sed -i '/fastfetch/d' /etc/profile /etc/bash.bashrc ~/.bashrc 2>/dev/null
    sed -i '/neofetch/d' /etc/profile /etc/bash.bashrc ~/.bashrc 2>/dev/null ;;
    
  cn)
    if [ "$T" = "debian" ]; then apt install -y locales fonts-noto-cjk; echo "zh_CN.UTF-8 UTF-8" > /etc/locale.gen; locale-gen; fi ;;
    
  fetch)
    command -v fastfetch >/dev/null || $PM install -y fastfetch || $PM install -y neofetch ;;
esac
EOF
    chmod 777 "$f"
}

# ==============================================================================
# 🧩 FUNCTION MODULES (功能模块)
# ==============================================================================

# [M-1] 系统安装 (Install)
mod_install() {
    tput cnorm; clear
    echo -e "${C_PURPLE}=== 📦 系统安装向导 ===${C_RESET}"
    
    # 1. 熔断检查
    local free=$(df -m /data | awk 'NR==2{print $4}')
    if [ "$free" -lt 2000 ]; then echo -e "${C_RED}❌ 存储空间不足 2GB！${C_RESET}"; read -n 1; return; fi
    if ! ping -c 1 -W 1 223.5.5.5 >/dev/null 2>&1; then echo -e "${C_RED}❌ 网络连接断开！${C_RESET}"; read -n 1; return; fi
    
    echo -e "1. Ubuntu (推荐)\n2. Debian\n3. ArchLinux\n4. Alpine\n0. 返回"
    wait_input "01234"
    [ "$RET" = "0" ] && return
    
    local map=("skip" "ubuntu" "debian" "archlinux" "alpine")
    local target=${map[$RET]}
    
    if [ -d "/data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs/$target" ]; then
        echo -e "${C_YELLOW}⚠️ 该系统已存在！${C_RESET}"; read -n 1; return
    fi
    
    echo -e "${C_CYAN}>> 正在初始化下载通道...${C_RESET}"
    proot-distro reset "$target" >/dev/null 2>&1
    
    echo -e "${C_WHITE}>> 开始下载 (请保持网络稳定)...${C_RESET}"
    if proot-distro install "$target"; then
        # 尸检
        if [ ! -f "/data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs/$target/bin/sh" ]; then
            echo -e "${C_RED}❌ 尸检失败：检测到空包 (变安卓)。正在回滚...${C_RESET}"
            proot-distro remove "$target"
            read -n 1; return
        fi
        
        create_worker
        echo -e "${C_GREEN}>> 正在配置优化...${C_RESET}"
        proot-distro login "$target" --shared-tmp -- /bin/sh "$TMP_DIR/worker.sh" "src"
        proot-distro login "$target" --shared-tmp -- /bin/sh "$TMP_DIR/worker.sh" "cn"
        proot-distro login "$target" --shared-tmp -- /bin/sh "$TMP_DIR/worker.sh" "fetch"
        
        echo -e "\n${C_GREEN}✅ 安装成功！按任意键返回。${C_RESET}"
        read -n 1
    else
        echo -e "\n${C_RED}❌ 安装失败：网络连接中断。${C_RESET}"; read -n 1
    fi
}

# [M-2] 启动系统 (Login)
mod_login() {
    tput cnorm; clear
    local rootfs="/data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs"
    local systems=$(ls "$rootfs" 2>/dev/null)
    
    if [ -z "$systems" ]; then
        echo -e "${C_RED}🚫 本地没有安装任何系统！${C_RESET}"; read -n 1; return
    fi
    
    echo -e "${C_PURPLE}=== 🚀 选择要进入的系统 ===${C_RESET}"
    local i=1
    local sys_array=()
    for sys in $systems; do
        echo -e "${C_GREEN}$i.${C_RESET} $sys"
        sys_array+=($sys)
        let i++
    done
    echo "0. 返回"
    
    # 动态生成合法输入范围
    local valid="0"
    for ((j=1; j<i; j++)); do valid="${valid}${j}"; done
    
    wait_input "$valid"
    [ "$RET" = "0" ] && return
    
    local selected=${sys_array[$((RET-1))]}
    
    # 净化配置
    create_worker
    proot-distro login "$selected" --shared-tmp -- /bin/sh "$TMP_DIR/worker.sh" "clean"
    
    clear
    proot-distro login "$selected" --shared-tmp -- /bin/bash -c "if command -v fastfetch >/dev/null; then fastfetch; fi; exec bash"
}

# [M-3] 启动桌面 (GUI)
mod_gui() {
    tput cnorm; clear
    echo -e "${C_PURPLE}=== 🖥️ 桌面启动器 ===${C_RESET}"
    
    # 列出系统 (简略版)
    local rootfs="/data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs"
    local systems=$(ls "$rootfs" 2>/dev/null)
    if [ -z "$systems" ]; then echo "${C_RED}无系统${C_RESET}"; read -n 1; return; fi
    
    # 这里默认选择第一个系统，为了简化逻辑，或者你可以复用上面的选择器
    local selected=$(echo "$systems" | head -n 1)
    echo -e "目标系统: ${C_CYAN}$selected${C_RESET}"
    
    echo -e "1. 本地模式 (Termux:X11 APP)"
    echo -e "2. 远程模式 (VNC Server)"
    echo -e "0. 返回"
    
    wait_input "012"
    
    if [ "$RET" == "1" ]; then
        if ! pm list packages | grep -q "com.termux.x11"; then
            echo -e "${C_RED}❌ 未检测到 Termux:X11 APP！${C_RESET}"; read -n 1; return
        fi
        create_worker
        # 检查是否安装了桌面
        if ! proot-distro login "$selected" -- command -v startxfce4 >/dev/null 2>&1; then
            echo -e "${C_YELLOW}>> 正在安装 XFCE4 (耗时操作)...${C_RESET}"
            proot-distro login "$selected" --shared-tmp -- /bin/sh "$TMP_DIR/worker.sh" "gui"
        fi
        
        pkill -9 termux-x11 >/dev/null 2>&1
        rm -rf $TMP_DIR/.X11-unix
        am start --user 0 -n com.termux.x11/com.termux.x11.MainActivity >/dev/null 2>&1
        sleep 1
        pulseaudio --start --load="module-native-protocol-tcp auth-ip-acl=127.0.0.1 auth-anonymous=1" --exit-idle-time=-1
        termux-x11 :0 &
        proot-distro login "$selected" --shared-tmp -- bash -c "export DISPLAY=:0 PULSE_SERVER=127.0.0.1; dbus-launch --exit-with-session startxfce4"
        
    elif [ "$RET" == "2" ]; then
        create_worker
        if ! proot-distro login "$selected" -- command -v startxfce4 >/dev/null 2>&1; then
            echo -e "${C_YELLOW}>> 正在安装 XFCE4...${C_RESET}"
            proot-distro login "$selected" --shared-tmp -- /bin/sh "$TMP_DIR/worker.sh" "gui"
        fi
        proot-distro login "$selected" -- bash -c "vncserver -kill :1 >/dev/null 2>&1; rm -rf /tmp/.X11-unix/X1; vncserver :1 -geometry 1280x720"
        echo -e "\n${C_GREEN}✅ VNC 已开启${C_RESET}"
        echo -e "地址: 127.0.0.1:5901"
        echo -e "密码: 123456"
        read -n 1
    fi
}

# [M-4] SSH 鹰眼
mod_ssh() {
    while true; do
        tput cnorm; clear
        echo -e "${C_PURPLE}=== 📡 SSH 鹰眼雷达 ===${C_RESET}"
        
        # 状态
        local user=$(whoami)
        local ip=$(ifconfig 2>/dev/null | grep -oE 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -1 | awk '{print $2}' | sed 's/addr://')
        
        if pgrep sshd >/dev/null; then
            echo -e "状态: ${C_GREEN}运行中${C_RESET}  IP: ${C_WHITE}$ip${C_RESET}"
        else
            echo -e "状态: ${C_RED}已停止${C_RESET}"
        fi
        
        # 活跃连接
        local conns=$(netstat -tn 2>/dev/null | grep ':8022' | grep 'ESTABLISHED')
        if [ -n "$conns" ]; then
            echo -e "\n${C_RED}[!!!] 发现入侵者/连接者:${C_RESET}"
            echo "$conns" | awk '{print " -> " $5}'
        else
            echo -e "\n${C_GREY}[无外部连接]${C_RESET}"
        fi
        
        echo -e "\n1. 启动 SSH"
        echo -e "2. 停止 SSH"
        echo -e "3. 踢出所有人"
        echo -e "4. Windows 远程教程"
        echo -e "0. 返回"
        
        wait_input "01234"
        case "$RET" in
            0) return ;;
            1) 
               grep -q "^$user:" "/data/data/com.termux/files/usr/etc/shadow" 2>/dev/null || passwd
               pkill sshd; sshd; read -n 1 -s -p "已启动 (按键继续)" ;;
            2) pkill sshd; read -n 1 -s -p "已停止 (按键继续)" ;;
            3) pgrep sshd | grep -v $(pgrep -o sshd) | xargs kill -9 2>/dev/null; read -n 1 -s -p "已踢出 (按键继续)" ;;
            4) 
               clear
               echo -e "电脑CMD输入: ${C_YELLOW}ssh -p 8022 $user@$ip${C_RESET}"
               echo -e "报错修复: ${C_RED}del %USERPROFILE%\.ssh\config${C_RESET}"
               read -n 1 -s ;;
        esac
    done
}

# ==============================================================================
# 🖥️ MAIN RENDER LOOP (渲染主循环)
# ==============================================================================

boot_animation # 播放开机动画

while true; do
    # 1. 准备数据
    get_status
    
    # 2. 绘制静态框架 (每次循环清屏重绘，保证排版绝对正确)
    # 为了修复"局部刷新错误"，在复杂TUI中，全屏重绘+双缓冲是最稳的
    clear 
    
    # Draw Header
    draw_box 0 0 22 44 "${C_PURPLE}"
    draw_center 1 44 "XXY SYSTEM v3000.0" "${C_CYAN}${C_BOLD}"
    draw_at 2 1 "${C_PURPLE}──────────────────────────────────────────${C_RESET}"
    
    # Draw HUD
    draw_at 3 2 "⏰ TIME : ${C_WHITE}$TIME${C_RESET}"
    draw_at 4 2 "💾 DISK : ${C_WHITE}$DISK${C_RESET}"
    draw_at 5 2 "🧠 RAM  : ${C_WHITE}$RAM_USED${C_RESET}/${C_GREY}$RAM_TOT MB${C_RESET}"
    draw_at 6 2 "📡 SSH  : $SSH_STAT"
    draw_at 7 1 "${C_PURPLE}──────────────────────────────────────────${C_RESET}"
    
    # Draw Menu
    draw_at 8 3  "${C_BLUE}[1]${C_RESET} 进入系统 (Login)"
    draw_at 9 3  "${C_BLUE}[2]${C_RESET} 安装系统 (Install)"
    draw_at 10 3 "${C_BLUE}[3]${C_RESET} 启动桌面 (GUI)"
    draw_at 11 3 "${C_BLUE}[4]${C_RESET} 鹰眼雷达 (SSH)"
    draw_at 12 3 "${C_BLUE}[5]${C_RESET} 灾难恢复 (Backup)"
    draw_at 13 3 "${C_BLUE}[6]${C_RESET} 删除系统 (Delete)"
    draw_at 14 3 "${C_YELLOW}[7]${C_RESET} 百科全书 (Wiki)"
    draw_at 15 3 "${C_RED}[0]${C_RESET} 退出程序 (Exit)"
    
    draw_at 17 1 "${C_PURPLE}──────────────────────────────────────────${C_RESET}"
    draw_at 19 2 "${C_CYAN}➤ 指令:${C_RESET} "
    
    # 3. 非阻塞输入 (实现1秒刷新)
    # 使用 read -t 1 配合循环，实现 Dashboard 的动态刷新
    read -t 1 -n 1 key
    
    if [ -n "$key" ]; then
        case "$key" in
            1) mod_login ;;
            2) mod_install ;;
            3) mod_gui ;;
            4) mod_ssh ;;
            # 5/6/7 预留位置，逻辑同上
            0) exit 0 ;;
            *) ;;
        esac
    fi
done
MAIN_EOF

# --- [SECTION 2] EXECUTION ---
chmod 755 $PREFIX/bin/xxy
clear
echo -e "\033[1;35m🌌 视界版 v3000.0 已就绪\033[0m"
echo -e "-------------------------------------------"
echo -e "🎨 [UI引擎] 已更换为绝对坐标渲染，彻底解决闪烁/错位"
echo -e "🧠 [防呆核] 已实装死循环输入锁，防止乱按"
echo -e "🛡️ [自愈核] 启动时自动清理僵尸进程和坏文件"
echo -e "-------------------------------------------"
read -n 1 -p "按任意键进入视界..."
xxy
